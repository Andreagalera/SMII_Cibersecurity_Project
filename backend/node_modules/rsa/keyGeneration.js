// Multilicar dos primso = n
// Toteinte (p-1)(q-1)
// Escoger e = 65537
// Verificar fi de n y e coprimo ( dividir fi de n entre e)
// clave pública (e, n)
// clave privada (inverso_modular ( e y fi d en))

  
'use strict';

//import * as bcu from 'bigint-crypto-utils';
const bcu = require('bigint-crypto-utils');

const _ONE = BigInt(1);
const e = BigInt(65537);

/**
 * @typedef {Object} KeyPair
 * @property {PublicKey} publicKey - a RSA's public key
 * @property {PrivateKey} privateKey - the associated RSA's private key
 */

 /**
 * Generates a pair private, public key for the RSA cryptosystem.
 * 
 * @param {number} [bitLength = 3072] - the bit length of the public modulo
 * @param {boolean} [simplevariant = false] - use the simple variant to compute the generator (g=n+1)
 * 
 * @returns {Promise} - a promise that resolves to a {@link KeyPair} of public, private keys
 */

const generateRandomKeys = async function (bitLength) {
    let p, q, n, phi, d ;
    // if p and q are bitLength/2 long ->  2**(bitLength - 2) <= n < 2**(bitLength) 
    do {
        p = await bcu.prime(Math.floor(bitLength / 2) + 1);
        q = await bcu.prime(Math.floor(bitLength / 2));
        n = p * q; 
        // Totiente
        phi = (p - _ONE) * (q - _ONE);
    } while (q === p || bcu.bitLength(n) != bitLength || bcu.gcd(phi, e) != 1);

   

    d = bcu.modInv(e,phi);


    // Clave pública
    const publicKey = new RSAPublicKey(e, n)
    // Clave privada
    const privateKey = new RSAPrivateKey(d,publicKey)

        
    return { publicKey: publicKey, privateKey: privateKey };


};


/**
 * Class for a RSA public key
 */
const RSAPublicKey = class PublicKey {

    
    constructor(e, n) {
        this.e = BigInt(e);
        this.n = BigInt(n);
    }

    encrypt(m) {
        let c;
        c = bcu.modPow(m, this.e, this.n);
        return c;
    }

    verify(s) {
        let m;
        m = bcu.modPow(s, this.e, this.n);
        return m;
    }
};

/**
 * Class for a RSA public key
 */
const RSAPrivateKey = class PublicKey {
    
        constructor(d, publicKey) {
            this.d = BigInt(d);
            this.publicKey = publicKey;
        }
    
        decrypt(c) {
            let m;
            m = bcu.modPow(c, this.d, this.publicKey.n);
            return m;
        }
        
        sign(m) {
            let s;
            s = bcu.modPow(m, this.d, this.publicKey.n);
            return s;
        }
    };

    module.exports = {
        generateRandomKeys: generateRandomKeys,
        PrivateKey: RSAPrivateKey,
        PublicKey: RSAPublicKey
    };
